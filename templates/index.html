<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Typing Pattern Tracker</title>
    <!-- Bootstrap CSS for Dark Theme -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom Styles -->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body class="bg-dark text-light">
    <div class="container mt-5">
        <div id="prompt-container" class="mb-4 p-4 rounded">
            <h3 id="prompt">{{ prompt }}</h3>
            <p id="progress">Prompt {{ current_prompt_number }} of {{ total_prompts }}</p>
        </div>
        <textarea id="response" class="form-control bg-secondary text-light" placeholder="Start typing here..."></textarea>
        <button id="submit-btn" class="btn btn-primary mt-3">Submit</button>
    </div>

    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const responseArea = document.getElementById('response');
        const submitBtn = document.getElementById('submit-btn');
        const promptElement = document.getElementById('prompt');
        const progressElement = document.getElementById('progress');

        let metrics = {
            word_metrics: [],
            overall_metrics: {},
            prompt: "{{ prompt }}",
            response: ""
        };

        let currentWord = "";
        let wordStartTime = null;
        let lastSpaceTime = null;
        let backspaceCountCurrentWord = 0;
        let totalBackspaces = 0;
        let totalStartTime = null;
        let totalEndTime = null;

        // Store the current prompt ID
        let currentPromptId = "{{ prompt_id }}";

        // Define a set of keys to ignore (non-typing keys)
        const ignoreKeys = new Set([
            "Shift", "Control", "Alt", "Meta", "CapsLock",
            "Tab", "Escape", "ArrowLeft", "ArrowRight",
            "ArrowUp", "ArrowDown", "Function", "F1", "F2", "F3",
            "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12",
            "Insert", "Delete", "Home", "End", "PageUp", "PageDown",
            "NumLock", "ScrollLock", "Pause", "PrintScreen"
        ]);

        // Optional: Define a regex pattern for acceptable characters
        const acceptableCharPattern = /^[a-zA-Z0-9.,!?'"():;@#$%^&*\-_=+\[\]{}|\\<>/`~ ]$/;

        // Event listeners for key presses
        responseArea.addEventListener('keydown', (e) => {
            const key = e.key;

            // Ignore keys in the ignoreKeys set
            if (ignoreKeys.has(key)) {
                return;
            }

            // Optionally, ensure the key is a single character
            if (key.length > 1 && key !== "Enter" && key !== " ") {
                return;
            }

            if (totalStartTime === null) {
                totalStartTime = performance.now();
                metrics.overall_metrics.start_time = new Date().toISOString();
            }

            const currentTime = performance.now();

            if (key === "Backspace") {
                backspaceCountCurrentWord += 1;
                totalBackspaces += 1;
                if (currentWord.length > 0) {
                    currentWord = currentWord.slice(0, -1);
                }
                return;
            }

            if (key === " " || key === "Enter") {
                if (currentWord.length > 0) {
                    const wordEndTime = currentTime;
                    const timeTaken = (wordEndTime - wordStartTime) / 1000; // in seconds
                    const wordLength = currentWord.length;

                    metrics.word_metrics.push({
                        word: currentWord,
                        time_taken_seconds: timeTaken,
                        backspaces: backspaceCountCurrentWord,
                        word_length: wordLength
                    });

                    currentWord = "";
                    backspaceCountCurrentWord = 0;
                    lastSpaceTime = currentTime;
                }

                // If Enter key is pressed, trigger the submit
                if (key === "Enter") {
                    e.preventDefault(); // Prevent adding a newline in the textarea
                    submitResponse();
                }
                return;
            }

            // Starting a new word
            if (currentWord.length === 0) {
                if (lastSpaceTime !== null) {
                    const delay = (currentTime - lastSpaceTime) / 1000; // in seconds
                    if (metrics.word_metrics.length > 0) {
                        metrics.word_metrics[metrics.word_metrics.length - 1]['delay_after_word_seconds'] = delay;
                    }
                }
                wordStartTime = currentTime;
            }

            currentWord += key;
        });

        // Function to handle submission
        function submitResponse() {
            // Handle the last word if not followed by space
            if (currentWord.length > 0) {
                const wordEndTime = performance.now();
                const timeTaken = (wordEndTime - wordStartTime) / 1000; // in seconds
                const wordLength = currentWord.length;

                metrics.word_metrics.push({
                    word: currentWord,
                    time_taken_seconds: timeTaken,
                    backspaces: backspaceCountCurrentWord,
                    word_length: wordLength
                });

                currentWord = "";
                backspaceCountCurrentWord = 0;
            }

            const totalEndTimeTemp = performance.now();
            const totalTime = (totalEndTimeTemp - totalStartTime) / 1000; // in seconds

            const wordsTyped = metrics.word_metrics.length;
            const wpm = (wordsTyped / totalTime) * 60;

            metrics.overall_metrics = {
                total_time_seconds: totalTime,
                total_backspaces: totalBackspaces,
                total_words: wordsTyped,
                wpm: wpm.toFixed(2),
                end_time: new Date().toISOString()
            };

            metrics.response = responseArea.value.trim();

            // Disable the submit button to prevent multiple submissions
            submitBtn.disabled = true;

            // Send data to the server
            fetch('/submit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(metrics),
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    if (data.next_prompt) {
                        // Display the next prompt after a 2-second pause
                        setTimeout(() => {
                            promptElement.textContent = data.next_prompt;
                            currentPromptId = data.next_prompt_id;
                            const currentPromptNumber = data.current_prompt_number;
                            progressElement.textContent = `Prompt ${currentPromptNumber} of {{ total_prompts }}`;
                            // Reset metrics for the next prompt
                            metrics = {
                                word_metrics: [],
                                overall_metrics: {},
                                prompt: data.next_prompt,
                                response: ""
                            };
                            currentWord = "";
                            wordStartTime = null;
                            lastSpaceTime = null;
                            backspaceCountCurrentWord = 0;
                            totalBackspaces = 0;
                            totalStartTime = null;
                            // Clear the textarea
                            responseArea.value = '';
                            submitBtn.disabled = false;
                        }, 1000);
                    } else if (data.status === 'completed') {
                        alert(`All prompts completed! Metrics saved to ${data.filename}`);
                        // Redirect to the home page or show a completion message
                        window.location.href = '/';
                    }
                } else {
                    // Handle errors properly
                    const errorMessage = data.message || 'An unknown error occurred.';
                    alert(`Error: ${errorMessage}`);
                    submitBtn.disabled = false;
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                alert('An error occurred while saving metrics.');
                submitBtn.disabled = false;
            });
        }

        // Add an event listener for the Enter key on the textarea to submit
        responseArea.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent adding a newline in the textarea
                submitResponse();
            }
        });

        // Event listener for the Submit button
        submitBtn.addEventListener('click', () => {
            submitResponse();
        });
    </script>
</body>
</html>
